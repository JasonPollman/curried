{"version":3,"sources":["index.js"],"names":["ceil","Math","chunk","array","chunkSize","size","length","n","i","c","e","results","Array"],"mappings":"0FAAA,kE,2EAEQA,CAAAA,I,CAASC,I,CAATD,I,CA0BO,QAASE,CAAAA,KAAT,CAAeC,CAAf,CAAsBC,CAAtB,CAAiC,CAC9C,GAAMC,CAAAA,CAAI,CAAGF,CAAK,CAACG,MAAnB,CACA,GAAI,CAACD,CAAL,CAAW,MAAO,EAAP,CAEX,GAAME,CAAAA,CAAC,CAA0D,CAAvD,EAAc,IAAb,EAAAH,CAAS,CAAY,sBAASA,CAAT,GAAuB,CAAnC,CAAwC,CAAlD,CAAV,CACA,GAAS,CAAL,EAAAG,CAAJ,CAAY,MAAO,EAAP,CALkC,GAO1CC,CAAAA,CAAC,CAAG,CAPsC,CAQ1CC,CAAC,CAAG,CARsC,CAS1CC,CAAC,CAAG,CATsC,CAcxCC,CAAO,CAAOC,KAAP,CAAaZ,IAAI,CAACK,CAAI,CAAGE,CAAR,CAAjB,CAdiC,CAe9CI,CAAO,CAAC,CAAD,CAAP,CAAiBC,KAAjB,CAAuBP,CAAI,CAAGE,CAAP,CAAWF,CAAX,CAAkBE,CAAzC,EAEA,MAAOC,CAAC,CAAGH,CAAX,CAAiB,CACfM,CAAO,CAACF,CAAD,CAAP,CAAWC,CAAC,EAAZ,EAAkBP,CAAK,CAACK,CAAC,EAAF,CAAvB,CAEA,GAAIE,CAAC,CAAGH,CAAC,CAAG,CAAR,EAAaC,CAAC,GAAKH,CAAvB,CAA6B,CAC3BM,CAAO,CAAC,EAAEF,CAAH,CAAP,CAAmBG,KAAnB,CAAyBP,CAAI,CAAGG,CAAP,CAAWD,CAAX,CAAeF,CAAI,CAAGG,CAAtB,CAA0BD,CAAnD,EACAG,CAAC,CAAG,CACL,CACF,CAED,MAAOC,CAAAA,CACR","sourceRoot":"packages/categories/array/chunk","sourcesContent":["import toNumber from '@foldr/to-number';\n\nconst { ceil } = Math;\n\n/**\n * Chunks an array into equal parts of size `n`.\n *\n * If the number of elements in the array doesn't split evenly, the last array in the\n * returned array will contain the remaining elements.\n *\n * @name chunk\n * @param {Array} array The array to chunk.\n * @param {number} [chunkSize=1] The number of elements (size) that should be in each chunk.\n * @returns {Array<Array>} The chunked array.\n *\n * @arity 2\n * @category array\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * import { chunk } from '@foldr/all';\n *\n * chunk([1, 2, 3, 4]);       // => [[1], [2], [3], [4]]\n * chunk([1, 2, 3, 4], 2);    // => [[1, 2], [3, 4]]\n * chunk([1, 2, 3, 4, 5], 3); // => [[1, 2], [3, 4], [5]]\n */\nexport default function chunk(array, chunkSize) {\n  const size = array.length;\n  if (!size) return [];\n\n  const n = (chunkSize != null ? (toNumber(chunkSize) || 0) : 1) | 0;\n  if (n <= 0) return [];\n\n  let i = 0;\n  let c = 0;\n  let e = 0;\n\n  // If you know the eventual size of the array, it's\n  // much faster to initialize with a given size since\n  // this will prevent reallocation later.\n  const results = new Array(ceil(size / n));\n  results[0] = new Array(size < n ? size : n);\n\n  while (i < size) {\n    results[c][e++] = array[i++];\n\n    if (e > n - 1 && i !== size) {\n      results[++c] = new Array(size - i < n ? size - i : n);\n      e = 0;\n    }\n  }\n\n  return results;\n}\n"]}