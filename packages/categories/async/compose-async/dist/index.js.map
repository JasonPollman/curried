{"version":3,"sources":["index.js"],"names":["ARITY","composeAsync","fns","arguments","n","length","Error","TypeError","size","last","next","context","index","result","call","composed","promise","Promise","resolve","then","apply","i"],"mappings":"sHAAA,8E,wEAQO,GAAMA,CAAAA,KAAK,CAAG,4BAAc,cAAd,CAAd,C,oBA8CQ,QAASC,CAAAA,YAAT,EAAwB,IAC/BC,CAAAA,CAAG,CAAGC,SADyB,CAEjCC,CAAC,CAAGF,CAAG,CAACG,MAFyB,CAIrC,GAAQ,CAAJ,CAAAD,CAAJ,CAAW,CACT,KAAM,IAAIE,CAAAA,KAAJ,CAAU,qDAAV,CACP,CAED,MAAc,CAAP,IAAEF,CAAT,CAAiB,CACf,GAAsB,UAAlB,QAAOF,CAAAA,CAAG,CAACE,CAAD,CAAd,CAAkC,CAChC,KAAM,IAAIG,CAAAA,SAAJ,CAAc,gEAAd,CACP,CACF,CAZoC,GAc/BC,CAAAA,CAAI,CAAGN,CAAG,CAACG,MAAJ,CAAa,CAdW,CAe/BI,CAAI,CAAGP,CAAG,CAACM,CAAD,CAfqB,CAgB/BE,CAAI,CAAG,SAACC,CAAD,CAAUC,CAAV,QAAoB,UAAAC,CAAM,QAAIX,CAAAA,CAAG,CAACU,CAAD,CAAH,CAAWE,IAAX,CAAgBH,CAAhB,CAAyBE,CAAzB,CAAJ,CAA1B,CAhBwB,CAkBrC,QAASE,CAAAA,CAAT,EAAoB,wBACdC,CAAO,CAAGC,OAAO,CAACC,OAAR,GAAkBC,IAAlB,CAAuB,iBAAMV,CAAAA,CAAI,CAACW,KAAL,CAAW,CAAX,CAAiBjB,CAAjB,CAAN,CAAvB,CADI,CAEdkB,CAAC,CAAGb,CAFU,CAIlB,MAAc,CAAP,IAAEa,CAAT,EAAiBL,CAAO,CAAGA,CAAO,CAACG,IAAR,CAAaT,CAAI,CAAC,IAAD,CAAOW,CAAP,CAAjB,CAA3B,CACA,MAAOL,CAAAA,CACR,CAIDD,CAAQ,CAACf,KAAD,CAAR,CAAkBS,CAAI,CAACT,KAAD,CAAJ,UAA4BS,CAAI,CAACT,KAAD,CAAhC,CAA0CS,CAAI,CAACJ,MAAjE,CACA,MAAOU,CAAAA,CACR","sourceRoot":"packages/categories/async/compose-async","sourcesContent":["import SafeSymbolFor from '@foldr/internal-symbol';\n\n/* eslint-disable require-jsdoc */\n\n/**\n * Used to track the arity of composed functions.\n * @type {SafeSymbol}\n */\nexport const ARITY = SafeSymbolFor('source-arity');\n\n/**\n * Composes promise returning functions.\n *\n * This function is similar to [compose](#compose), except that it works\n * for promise returning functions.\n *\n * You can combine synchronous and asynchronous functions, but `composeAsync`\n * will always return a Promise object.\n *\n * @name composeAsync\n * @param {...function} functions The promise returning functions to compose.\n * @returns {function} The composite async function.\n *\n * @arity Infinity\n * @category async\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * import { composeAsync } from '@foldr/all';\n *\n * function getUserRecordWithId(id) {\n *   // Get the user from a db somehow...\n *   return Promise.resolve().then(() => ({\n *     id: 1234,\n *     firstName: 'Will',\n *     lastName: 'Smith',\n *   }))\n * }\n *\n * function formatUserName(user) {\n *   return `${user.firstName} ${user.lastName}`;\n * }\n *\n * const getAndPrintUserName = composeAsync(\n *   formatUserName,\n *   getUserRecordWithId,\n * );\n *\n * getAndPrintUserName();\n * // => 'Will Smith'\n *\n */\nexport default function composeAsync() {\n  const fns = arguments;\n  let n = fns.length;\n\n  if (n < 2) {\n    throw new Error('You must provide at least two functions to compose.');\n  }\n\n  while (--n >= 0) {\n    if (typeof fns[n] !== 'function') {\n      throw new TypeError('The composeAsync function only accepts functions as arguments.');\n    }\n  }\n\n  const size = fns.length - 1;\n  const last = fns[size];\n  const next = (context, index) => result => fns[index].call(context, result);\n\n  function composed() {\n    let promise = Promise.resolve().then(() => last.apply(this, arguments));\n    let i = size;\n\n    while (--i >= 0) promise = promise.then(next(this, i));\n    return promise;\n  }\n\n  // So we can apply function transformations to async composed functions,\n  // we stash the arity here. For example, currying an async composed function.\n  composed[ARITY] = last[ARITY] !== undefined ? last[ARITY] : last.length;\n  return composed;\n}\n"]}