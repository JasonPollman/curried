{"version":3,"sources":["index.js"],"names":["ARITY","compose","fns","arguments","n","length","Error","TypeError","size","last","composed","i","result","apply","call"],"mappings":"iHAAA,8E,wEAQO,GAAMA,CAAAA,KAAK,CAAG,4BAAc,cAAd,CAAd,C,oBAsCQ,QAASC,CAAAA,OAAT,EAAmB,IAC1BC,CAAAA,CAAG,CAAGC,SADoB,CAE5BC,CAAC,CAAGF,CAAG,CAACG,MAFoB,CAIhC,GAAQ,CAAJ,CAAAD,CAAJ,CAAW,CACT,KAAM,IAAIE,CAAAA,KAAJ,CAAU,qDAAV,CACP,CAED,MAAc,CAAP,IAAEF,CAAT,CAAiB,CACf,GAAsB,UAAlB,QAAOF,CAAAA,CAAG,CAACE,CAAD,CAAd,CAAkC,CAChC,KAAM,IAAIG,CAAAA,SAAJ,CAAc,2DAAd,CACP,CACF,CAZ+B,GAc1BC,CAAAA,CAAI,CAAGN,CAAG,CAACG,MAAJ,CAAa,CAdM,CAe1BI,CAAI,CAAGP,CAAG,CAACM,CAAD,CAfgB,CAiBhC,QAASE,CAAAA,CAAT,EAAoB,IACdC,CAAAA,CAAC,CAAGH,CADU,CAEdI,CAAM,CAAGV,CAAG,CAACS,CAAD,CAAH,CAAOE,KAAP,CAAa,IAAb,CAAmBV,SAAnB,CAFK,CAIlB,MAAc,CAAP,IAAEQ,CAAT,EAAiBC,CAAM,CAAGV,CAAG,CAACS,CAAD,CAAH,CAAOG,IAAP,CAAY,IAAZ,CAAkBF,CAAlB,CAA1B,CACA,MAAOA,CAAAA,CACR,CAIDF,CAAQ,CAACV,KAAD,CAAR,CAAkBS,CAAI,CAACT,KAAD,CAAJ,UAA4BS,CAAI,CAACT,KAAD,CAAhC,CAA0CS,CAAI,CAACJ,MAAjE,CACA,MAAOK,CAAAA,CACR","sourceRoot":"packages/categories/function/compose","sourcesContent":["import SafeSymbolFor from '@foldr/internal-symbol';\n\n/* eslint-disable require-jsdoc */\n\n/**\n * Used to track the arity of composed functions.\n * @type {SafeSymbol}\n */\nexport const ARITY = SafeSymbolFor('source-arity');\n\n/**\n * Function composition.\n *\n * Creates a new function that returns the result of invoking\n * the given functions in successive order from right to left,\n * passing the results of the previous invocation to the next.\n *\n * Each function will be invoked with the `this` binding available\n * to the newly created function.\n *\n * This function is very similar to `pipe`, except that the order\n * of function execution flows from right to left (bottom to top).\n *\n * @name compose\n * @param {...function} functions The functions to compose.\n * @returns {function} The composite function.\n *\n * @arity Infinity\n * @category function\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * function add(a, b) {\n *   return a + b;\n * }\n *\n * function square(x) {\n *   return x * x;\n * }\n *\n * const sumSquared = compose(square, add);\n * sumSquared(1, 2); // => 9\n * sumSquared(2, 3); // => 25\n */\nexport default function compose() {\n  const fns = arguments;\n  let n = fns.length;\n\n  if (n < 2) {\n    throw new Error('You must provide at least two functions to compose.');\n  }\n\n  while (--n >= 0) {\n    if (typeof fns[n] !== 'function') {\n      throw new TypeError('The compose function only accepts functions as arguments.');\n    }\n  }\n\n  const size = fns.length - 1;\n  const last = fns[size];\n\n  function composed() {\n    let i = size;\n    let result = fns[i].apply(this, arguments);\n\n    while (--i >= 0) result = fns[i].call(this, result);\n    return result;\n  }\n\n  // So we can apply function transformations to composed functions,\n  // we stash the arity here. For example, currying a composed function.\n  composed[ARITY] = last[ARITY] !== undefined ? last[ARITY] : last.length;\n  return composed;\n}\n"]}