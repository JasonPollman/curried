{"version":3,"sources":["index.js"],"names":["ARITY","SOURCE","toStringForMemoized","concat","toString","hasOwnProperty","Object","prototype","del","key","has","size","data","set","value","get","call","clear","DefaultCache","delete","emsg","arg","memoize","fn","resolver","JSON","stringify","mcache","Error","memoized","cache","arguments","results","apply","length","Cache"],"mappings":"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","sourceRoot":"packages/categories/function/memoize","sourcesContent":["import SafeSymbolFor from '@foldr/internal-symbol';\n\n/**\n * Used to track the arity of partialed functions.\n * @type {SafeSymbol}\n */\nexport const ARITY = SafeSymbolFor('source-arity');\n\n/**\n * Used to map partialed functions back to their original.\n * @type {SafeSymbol}\n */\nexport const SOURCE = SafeSymbolFor('source-fn');\n\n/**\n * The `toString` implementation for memoized functions.\n * This will print the original function's source string\n * prepended with a friendly message that the function is memoized.\n * @returns {string} The source function's code with a comment\n * informing the user that the function is partialized.\n */\nfunction toStringForMemoized() {\n  return '/* Memoized */\\r\\n'.concat(this[SOURCE].toString());\n}\n\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n * Default cache `delete` implementation.\n * @param {string} key The cache key to delete.\n * @returns {Cache} The current cache object.\n */\nfunction del(key) {\n  if (this.has(key)) {\n    this.size--;\n    delete this.data[key];\n  }\n\n  return this;\n}\n\n/**\n * Default cache `set` implementation.\n * @param {string} key The cache key to set.\n * @param {any} value The value to store as `key` on the cache.\n * @returns {Cache} The current cache object.\n */\nfunction set(key, value) {\n  if (!this.has(key)) {\n    this.size++;\n    this.data[key] = value;\n  }\n\n  return this;\n}\n\n/**\n * Default cache `get` implementation.\n * @param {string} key The cache key to get.\n * @returns {any} The value of the cache key `key` or undefined.\n */\nfunction get(key) {\n  return this.data[key];\n}\n\n/**\n * Default cache `has` implementation.\n * @param {string} key The cache key to assert cache membership of.\n * @returns {boolean} True if the cache has the key, false otherwise.\n */\nfunction has(key) {\n  return hasOwnProperty.call(this.data, key);\n}\n\n/**\n * Default cache `clear` implementation.\n * @returns {Cache} The current cache object.\n */\nfunction clear() {\n  this.size = 0;\n  this.data = {};\n  return this;\n}\n\n/**\n * Internal implementation of Map for memoize purposes.\n * @returns {Object} A \"cache\" object.\n */\nfunction DefaultCache() {\n  return {\n    has,\n    set,\n    get,\n    clear,\n    size: 0,\n    data: {},\n    delete: del,\n  };\n}\n\n/**\n * Creates an error message string for memoize.\n * @param {string} arg The name of the argument to create the message for.\n * @returns {string} The error message string.\n */\nfunction emsg(arg) {\n  return `Argument for parameter \"${arg}\" must be a function.`;\n}\n\n/**\n * Creates a memoized version of `fn`.\n *\n * That is, a function that caches calls based on the \"signature\" of the provided arguments.\n * If the function is invoked multiple times with the same arguments signature, the results\n * from the first invocation is returned.\n *\n * `memoize` uses the value of `memoize.Cache` to create new cache objects that store the\n * results calls to `fn`. You can override `memoize.Cache` with anything that implements\n * a `Map` like interface.\n *\n * @name memoize\n * @param {function} fn The function to memoize.\n * @param {function=} [resolver=memoize.resolver] The cache key resolver. This is a function\n * used to generate the cache key for the current call. This should serialize arguments in\n * a way that is unique for the arguments set. It is passed the input Arguments object.\n * Default value is `JSON.stringify`.\n * @param {object=} [mcache=new memoize.Cache()] The cache instance for the memoized function.\n * This requires an object with an interface similar to the native Map object.\n * Custom implementations require implementing the following methods:\n *  - `has`\n *  - `get`\n *  - `set`\n *  - `size`\n *  - `clear`\n *  - `delete`\n * @returns {function} The memoized version of `fn`.\n *\n * @arity 1\n * @category function\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * import { memoize } from '@foldr/all';\n *\n * function fibonacci(n) {\n *   return n <= 1 ? 1 : fibonacci(n - 2) + fibonacci(n - 1);\n * }\n *\n * // Takes about ~12-15 seconds.\n * fibonacci(45); // => 1836311903\n *\n * const fastFibonacci = memoize((n) => {\n *   return n <= 1 ? 1 : fastFibonacci(n - 2) + fastFibonacci(n - 1);\n * });\n *\n * // Takes less than a second (only a few ms, actually).\n * fastFibonacci(45); // => 1836311903\n */\nexport default function memoize(fn, resolver = JSON.stringify, mcache) {\n  if (typeof fn !== 'function') throw new Error(emsg('fn'));\n  if (typeof resolver !== 'function') throw new Error(emsg('resolver'));\n\n  // eslint-disable-next-line require-jsdoc\n  function memoized() {\n    const { cache } = memoized;\n    const key = resolver(arguments);\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    const results = fn.apply(this, arguments);\n    cache.set(key, results);\n    return results;\n  }\n\n  memoized[ARITY] = fn[ARITY] !== undefined ? fn[ARITY] : fn.length;\n  memoized[SOURCE] = fn;\n\n  memoized.cache = mcache || new memoize.Cache();\n  memoized.toString = toStringForMemoized;\n\n  return memoized;\n}\n\nmemoize.Cache = DefaultCache;\n"]}