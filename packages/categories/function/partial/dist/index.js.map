{"version":3,"sources":["index.js"],"names":["_","IS_PARTIAL","ARITY","SOURCE","toStringForPartialed","concat","toString","partialize","fn","partials","applied","length","input","arguments","output","size","i","n","apply","partial","TypeError","partialized","arity"],"mappings":"6JAAA,8E,wEAMO,GAAMA,CAAAA,CAAC,CAAG,4BAAc,aAAd,CAAV,C,YAMA,GAAMC,CAAAA,UAAU,CAAG,4BAAc,eAAd,CAAnB,C,8BAMA,GAAMC,CAAAA,KAAK,CAAG,4BAAc,cAAd,CAAd,C,oBAMA,GAAMC,CAAAA,MAAM,CAAG,4BAAc,WAAd,CAAf,C,sBASP,QAASC,CAAAA,oBAAT,EAAgC,CAC9B,MAAO,4BAA4BC,MAA5B,CAAmC,KAAKF,MAAL,EAAaG,QAAb,EAAnC,CACR,CAQD,QAASC,CAAAA,UAAT,CAAoBC,CAApB,CAAwBC,CAAxB,CAAkC,CAChC,GAAMC,CAAAA,CAAO,CAAGD,CAAQ,CAACE,MAAzB,CAEA,MAAO,WAAuB,IACtBC,CAAAA,CAAK,CAAGC,SADc,CAEtBC,CAAM,CAAG,EAFa,CAItBC,CAAI,CAAGH,CAAK,CAACD,MAJS,CAMxBK,CAAC,CAAG,CANoB,CAOxBC,CAAC,CAAG,CAPoB,CAW5B,MAAOD,CAAC,CAAGN,CAAX,CAAoB,CAClBI,CAAM,CAACE,CAAD,CAAN,CAAYP,CAAQ,CAACO,CAAD,CAAR,GAAgBhB,CAAhB,CAAoBY,CAAK,CAACK,CAAC,EAAF,CAAzB,CAAiCR,CAAQ,CAACO,CAAD,CAArD,CACAA,CAAC,EACF,CAGD,MAAOC,CAAC,CAAGF,CAAX,EAAiBD,CAAM,CAACE,CAAC,EAAF,CAAN,CAAcJ,CAAK,CAACK,CAAC,EAAF,CAApC,CACA,MAAOT,CAAAA,CAAE,CAACU,KAAH,CAAS,IAAT,CAAeJ,CAAf,CACR,CACF,CAoCc,QAASK,CAAAA,OAAT,CAAiBX,CAAjB,CAAkC,CAC/C,GAAkB,UAAd,QAAOA,CAAAA,CAAX,CAA8B,CAC5B,KAAM,IAAIY,CAAAA,SAAJ,CAAc,2DAAd,CACP,CAH8C,2BAAVX,CAAU,+BAAVA,CAAU,mBAM/C,GAAI,CAACA,CAAQ,CAACE,MAAd,CAAsB,MAAOH,CAAAA,CAAP,CANyB,GAQzCa,CAAAA,CAAW,CAAGd,UAAU,CAACC,CAAD,CAAKC,CAAL,CARiB,CAU3CO,CAAC,CAAGP,CAAQ,CAACE,MAV8B,CAW3CW,CAAK,CAAgB,CAAb,EAAAd,CAAE,CAACN,KAAD,CAAF,CAAiBM,CAAE,CAACN,KAAD,CAAnB,CAA6BM,CAAE,CAACG,MAXG,CAe/C,MAAc,CAAP,IAAEK,CAAT,EAAiB,GAAIP,CAAQ,CAACO,CAAD,CAAR,GAAgBhB,CAApB,CAAuBsB,CAAK,EAA7C,CAEAD,CAAW,CAACnB,KAAD,CAAX,CAAqBoB,CAArB,CACAD,CAAW,CAAClB,MAAD,CAAX,CAAsBK,CAAtB,CACAa,CAAW,CAACpB,UAAD,CAAX,IACAoB,CAAW,CAACf,QAAZ,CAAuBF,oBAAvB,CAEA,MAAOiB,CAAAA,CACR,CAEDF,OAAO,CAACnB,CAAR,CAAYA,CAAZ","sourceRoot":"packages/categories/function/partial","sourcesContent":["import SafeSymbolFor from '@foldr/internal-symbol';\n\n/**\n * The default placeholder value.\n * @type {SafeSymbol}\n */\nexport const _ = SafeSymbolFor('placeholder');\n\n/**\n * Used to determine if a function is partialed.\n * @type {SafeSymbol}\n */\nexport const IS_PARTIAL = SafeSymbolFor('is-partial-fn');\n\n/**\n * Used to track the arity of partialed functions.\n * @type {SafeSymbol}\n */\nexport const ARITY = SafeSymbolFor('source-arity');\n\n/**\n * Used to map partialed functions back to their original.\n * @type {SafeSymbol}\n */\nexport const SOURCE = SafeSymbolFor('source-fn');\n\n/**\n * The `toString` implementation for partialed functions.\n * This will print the original function's source string\n * prepended with a friendly message that the function is partialized.\n * @returns {string} The source function's code with a comment\n * informing the user that the function is partialized.\n */\nfunction toStringForPartialed() {\n  return '/* Partial Wrapped */\\r\\n'.concat(this[SOURCE].toString());\n}\n\n/**\n * Partializes `fn` using `partials`.\n * @param {function} fn The function to partialize.\n * @param {Array} partials The set of partial arguments to apply to `fn`.\n * @returns {function} The partialized function.\n */\nfunction partialize(fn, partials) {\n  const applied = partials.length;\n\n  return function partialized() {\n    const input = arguments;\n    const output = [];\n\n    const size = input.length;\n\n    let i = 0;\n    let n = 0;\n\n    // Push partial applications into the final arguments set\n    // if they're placeholders, grab them from `arguments`.\n    while (i < applied) {\n      output[i] = partials[i] === _ ? input[n++] : partials[i];\n      i++;\n    }\n\n    // Push remaining arguments into the final arguments set.\n    while (n < size) output[i++] = input[n++];\n    return fn.apply(this, output);\n  };\n}\n\n/**\n * Creates a function that \"binds\" arguments to the given function. This function\n * operates much like Function#bind, except that it does not alter the `this` value\n * and it provides the flexibility of using placeholder values to \"skip\" arguments\n * you don't want to apply.\n *\n * @param {function} fn The function to partialize.\n * @returns {function} The partialized function.\n *\n * @arity Infinity\n * @category function\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * import { partial } from '@foldr/partial';\n *\n * function pow(x, y) {\n *   return x ** y;\n * }\n *\n * const powerOf2 = partial(pow, 2);\n * powerOf2(1); // => 2\n * powerOf2(2); // => 4\n * powerOf2(3); // => 8\n *\n * // Using placeholders we can use the same function\n * // to achieve different functionality.\n * const square = partial(pow, _, 2);\n * square(1); // => 1\n * square(2); // => 2\n * square(3); // => 9\n */\nexport default function partial(fn, ...partials) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The first argument given to `partial` must be a function.');\n  }\n\n  // No reason to partialize a function with no partials or a curried function.\n  if (!partials.length) return fn;\n\n  const partialized = partialize(fn, partials);\n\n  let i = partials.length;\n  let arity = fn[ARITY] >= 0 ? fn[ARITY] : fn.length;\n\n  // We have to adjust the arity of the partialized function\n  // so if curried it will curry properly.\n  while (--i >= 0) if (partials[i] !== _) arity--;\n\n  partialized[ARITY] = arity;\n  partialized[SOURCE] = fn;\n  partialized[IS_PARTIAL] = true;\n  partialized.toString = toStringForPartialed;\n\n  return partialized;\n}\n\npartial._ = _;\n"]}