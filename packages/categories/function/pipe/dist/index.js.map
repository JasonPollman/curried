{"version":3,"sources":["index.js"],"names":["ARITY","TYPE_ERROR","pipe","funcs","arguments","argLen","length","Error","TypeError","size","receiver","value","apply","len","call","first"],"mappings":"yGAAA,8E,wEAQO,GAAMA,CAAAA,KAAK,CAAG,4BAAc,cAAd,CAAd,C,oBAMP,GAAMC,CAAAA,UAAU,CAAG,mDAAnB,CA2BA,QAASC,CAAAA,IAAT,EAAgB,IACRC,CAAAA,CAAK,CAAGC,SADA,CAGVC,CAAM,CAAGF,CAAK,CAACG,MAHL,CAId,GAAI,CAACD,CAAL,CAAa,KAAM,IAAIE,CAAAA,KAAJ,CAAUN,UAAV,CAAN,CAEb,MAAO,EAAEI,CAAT,CAAiB,CACf,GAAiC,UAA7B,QAAOD,CAAAA,SAAS,CAACC,CAAD,CAApB,CAA6C,CAC3C,KAAM,IAAIG,CAAAA,SAAJ,CAAcP,UAAd,CACP,CACF,CAED,GAAMQ,CAAAA,CAAI,CAAGN,CAAK,CAACG,MAAnB,CAEA,QAASI,CAAAA,CAAT,EAAoB,IACdC,CAAAA,CAAK,CAAGR,CAAK,CAAC,CAAD,CAAL,CAASS,KAAT,CAAe,IAAf,CAAqBR,SAArB,CADM,CAEdS,CAAG,CAAG,CAFQ,CAIlB,MAAO,EAAEA,CAAF,CAAQJ,CAAf,EAAqBE,CAAK,CAAGR,CAAK,CAACU,CAAD,CAAL,CAAWC,IAAX,CAAgB,IAAhB,CAAsBH,CAAtB,CAA7B,CACA,MAAOA,CAAAA,CACR,CAED,GAAMI,CAAAA,CAAK,CAAGZ,CAAK,CAAC,CAAD,CAAnB,CAIAO,CAAQ,CAACV,KAAD,CAAR,CAAkBe,CAAK,CAACf,KAAD,CAAL,UAA6Be,CAAK,CAACf,KAAD,CAAlC,CAA4Ce,CAAK,CAACT,MAApE,CACA,MAAOI,CAAAA,CACR,C,aAEcR,I","sourceRoot":"packages/categories/function/pipe","sourcesContent":["import SafeSymbolFor from '@foldr/internal-symbol';\n\n/* eslint-disable require-jsdoc */\n\n/**\n * Used to track the arity of piped functions.\n * @type {SafeSymbol}\n */\nexport const ARITY = SafeSymbolFor('source-arity');\n\n/**\n * Generic type error\n * @type {string}\n */\nconst TYPE_ERROR = 'Expected arguments of pipe to be of type function';\n\n/**\n * Takes in functions as parameters, and returns a function\n * that takes in the initial arguments to pass to the first function in the pipe chain.\n *\n * After the first function in the pipe chain completes, that value is then passed to the next\n * function in the pipe chain, and so on.\n *\n * @param {Array<function>} arguments - functions to pipe data through\n * @returns {*} - whatever is returned from the pipe chain.\n *\n * @arity 1\n * @category function\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * import { pipe } from '@foldr/all';\n *\n * const add = (a, b) => a + b;\n * const mult = a => a * a;\n *\n * const piped = pipe(add, mult)\n * piped(2, 3) // => 25;\n */\nfunction pipe() {\n  const funcs = arguments;\n\n  let argLen = funcs.length;\n  if (!argLen) throw new Error(TYPE_ERROR);\n\n  while (--argLen) {\n    if (typeof arguments[argLen] !== 'function') {\n      throw new TypeError(TYPE_ERROR);\n    }\n  }\n\n  const size = funcs.length;\n\n  function receiver() {\n    let value = funcs[0].apply(this, arguments);\n    let len = 0;\n\n    while (++len < size) value = funcs[len].call(this, value);\n    return value;\n  }\n\n  const first = funcs[0];\n\n  // So we can apply function transformations to piped functions\n  // we stash the arity here. For example, currying a composed function.\n  receiver[ARITY] = first[ARITY] !== undefined ? first[ARITY] : first.length;\n  return receiver;\n}\n\nexport default pipe;\n"]}