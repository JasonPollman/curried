{"version":3,"sources":["index.js"],"names":["rearg","fn","signature","TypeError"],"mappings":"0FAAA,4E,wEAsCe,QAASA,CAAAA,KAAT,CAAeC,CAAf,CAAmBC,CAAnB,CAA8B,CAC3C,GAAkB,UAAd,QAAOD,CAAAA,CAAX,CAA8B,CAC5B,KAAM,IAAIE,CAAAA,SAAJ,CAAc,yDAAd,CACP,CAED,MAAO,2BAAcF,CAAd,CAAkBC,CAAlB,CACR","sourceRoot":"packages/categories/function/rearg","sourcesContent":["import internalRearg from '@foldr/internal-rearg';\n\n/**\n * Creates a function that \"rearranges\" the arguments signature of `fn`.\n *\n * This will return a wrapper function that, when called, will call `fn`\n * with arguments rearranged by the index mapping of the `signature` array.\n *\n * @name rearg\n * @param {function} fn The function to rearg.\n * @param {Array<number>} signature An array who's values indicate the actual arguments\n * to use for that index of the array. For example, `[1, 0, 2]` would convert the arguments\n * signature `fn(x, y, z)` to `fn(y, x, z)`.\n * @returns {function} The rearged function.\n *\n * @arity 2\n * @category function\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * import { rearg } from '@foldr/all';\n *\n * function foo(x, y, z) {\n *   return x + y + z;\n * }\n *\n * const rearged = rearg(foo, [1, 0, 2]);\n *\n * foo('a', 'b', 'c'); // => 'abc';\n * rearged('a', 'b', 'c'); // => 'bac';\n *\n * const rearged2 = rearg(foo, [0, 0, 0]);\n *\n * foo('a', 'b', 'c'); // => 'abc';\n * rearged('a', 'b', 'c'); // => 'aaa';\n */\nexport default function rearg(fn, signature) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The first argument given to `rearg` must be a function.');\n  }\n\n  return internalRearg(fn, signature);\n}\n"]}