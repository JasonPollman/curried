{"version":3,"sources":["index.js"],"names":["flattenDeepBase","array","maxDepth","results","depth","size","length","delta","i","current","flattenDeep","f","arity","signature"],"mappings":"iUAiBA,QAASA,CAAAA,eAAT,CAAyBC,CAAzB,CAAgCC,CAAhC,CAA0CC,CAA1C,CAAmDC,CAAnD,CAA0D,IAClDC,CAAAA,CAAI,CAAGJ,CAAK,CAACK,MADqC,CAElDC,CAAK,CAAGH,CAAK,CAAG,CAFkC,CAIpDI,CAAC,CAAG,CAJgD,CAKpDC,CALoD,CAOxD,MAAOD,CAAC,CAAGH,CAAX,CAAiB,CACfI,CAAO,CAAGR,CAAK,CAACO,CAAC,EAAF,CAAf,CAEA,GAAID,CAAK,EAAIL,CAAT,EAAqB,qBAAQO,CAAR,CAAzB,CAA2C,CACzCT,eAAe,CAACS,CAAD,CAAUP,CAAV,CAAoBC,CAApB,CAA6BI,CAA7B,CAChB,CAFD,IAEO,CACLJ,CAAO,CAACA,CAAO,CAACG,MAAT,CAAP,CAA0BG,CAC3B,CACF,CAED,MAAON,CAAAA,CACR,CAsBc,QAASO,CAAAA,WAAT,CAAqBT,CAArB,CAA4BC,CAA5B,CAAsC,CACnD,GAAI,CAACD,CAAD,EAAU,CAACA,CAAK,CAACK,MAArB,CAA6B,MAAO,EAAP,CAC7B,MAAON,CAAAA,eAAe,CAACC,CAAD,CAAQ,CAACC,CAAD,KAAR,CAA+B,EAA/B,CAAmC,CAAnC,CACvB,CA0BM,GAAMS,CAAAA,CAAC,CAAG,2BAAkBD,WAAlB,CAA+B,CAC9CE,KAAK,CAAE,CADuC,CAE9CC,SAAS,CAAE,CAAC,CAAD,CAAI,CAAJ,CAFmC,CAA/B,CAAV,C","sourceRoot":"packages/categories/functional/flatten-deep-fx","sourcesContent":["/**\n * Exports the flatten function.\n * @since 10/14/18\n * @file\n */\n\nimport isArray from '@foldr/is-array';\nimport FunctionalFactory from '@foldr/internal-fmake';\n\n/**\n * Base recursive functionality for `flattenDeep`.\n * @param {Array} array The array to deeply flatten.\n * @param {number} maxDepth The maximum depth to flatten to.\n * @param {Array} results A results \"collection\" array.\n * @param {number} depth The current flattening depth.\n * @returns {Array} The flattened array.\n */\nfunction flattenDeepBase(array, maxDepth, results, depth) {\n  const size = array.length;\n  const delta = depth + 1;\n\n  let i = 0;\n  let current;\n\n  while (i < size) {\n    current = array[i++];\n\n    if (delta <= maxDepth && isArray(current)) {\n      flattenDeepBase(current, maxDepth, results, delta);\n    } else {\n      results[results.length] = current; // eslint-disable-line no-param-reassign\n    }\n  }\n\n  return results;\n}\n\n/**\n * Flattens an array to the specified depth (which defaults to `Infinity`).\n * This will iterate over the provided array pushing all items into a new array.\n * If the current item is an array, it's contents will also be pushed into the new array.\n *\n * @name flattenDeep\n * @param {Array} array The array to deeply flatten.\n * @param {number=} [maxDepth=Infinity] The maximum depth to flatten to.\n * @returns {Array} A newly flattened array.\n *\n * @category array\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * flattenDeep([1, 2, 3, 4]);                 // => [1, 2, 3, 4]\n * flattenDeep([1, [2, [3, 4, [5, 6]], [7]]); // => [1, 2, 3, 4, 5, 6, 7]\n * flattenDeep([[1], [2], [3], 4]);           // => [1, 2, 3, 4]\n */\nexport default function flattenDeep(array, maxDepth) {\n  if (!array || !array.length) return [];\n  return flattenDeepBase(array, +maxDepth || Infinity, [], 0);\n}\n\n/**\n * Functional, autocurried version of [flattenDeep](#flatten-deep).\n *\n * Flattens an array to the specified depth (which defaults to `Infinity`).\n * This will iterate over the provided array pushing all items into a new array.\n * If the current item is an array, it's contents will also be pushed into the new array.\n *\n * @name flattenDeep.f\n * @param {number} maxDepth The maximum depth to flatten to.\n * @param {Array} array The array to deeply flatten.\n * @returns {Array} A newly flattened array.\n *\n * @arity 2\n * @autocurried\n * @category functional\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * flattenDeep.f(1)([1, 2, 3, 4]);                  // => [1, 2, 3, 4]\n * flattenDeep.f(10)([1, [2, [3, 4, [5, 6]], [7]]); // => [1, 2, 3, 4, 5, 6, 7]\n * flattenDeep.f(Infinity)([[1], [2], [3], 4]);     // => [1, 2, 3, 4]\n */\nexport const f = FunctionalFactory(flattenDeep, {\n  arity: 2,\n  signature: [1, 0],\n});\n"]}