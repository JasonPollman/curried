{"version":3,"sources":["index.js"],"names":["get","object","path","fallback","props","size","length","current","i","f","arity","signature"],"mappings":"uTA+Be,QAASA,CAAAA,GAAT,CAAaC,CAAb,CAAqBC,CAArB,CAA2BC,CAA3B,CAAqC,IAC5CC,CAAAA,CAAK,CAAG,oBAAOF,CAAP,CADoC,CAE5CG,CAAI,CAAGD,CAAK,CAACE,MAF+B,CAIlD,GAAI,CAACD,CAAD,EAAS,CAACJ,CAAd,CAAsB,MAAOE,CAAAA,CAAP,CAJ4B,GAM9CI,CAAAA,CAAO,CAAGN,CANoC,CAO9CO,CAAC,CAAG,CAP0C,CASlD,GAAa,CAAT,GAAAH,CAAJ,CAAgB,CACdE,CAAO,CAAGN,CAAM,CAACG,CAAK,CAAC,CAAD,CAAN,CACjB,CAFD,IAEO,CACL,MAAOI,CAAC,CAAGH,CAAJ,EAAuB,IAAX,EAAAE,CAAnB,CAAoC,CAClCA,CAAO,CAAGA,CAAO,CAACH,CAAK,CAACI,CAAC,EAAF,CAAN,CAClB,CACF,CAED,MAAOD,CAAAA,CAAO,SAAP,CAAwBJ,CAAxB,CAAmCI,CAC3C,CAoCM,GAAME,CAAAA,CAAC,CAAG,2BAAkBT,GAAlB,CAAuB,CACtCU,KAAK,CAAE,CAD+B,CAEtCC,SAAS,CAAE,CAAC,CAAD,CAAI,CAAJ,CAF2B,CAAvB,CAAV,C","sourceRoot":"packages/categories/functional/get-fx","sourcesContent":["import toPath from '@foldr/to-path';\nimport FunctionalFactory from '@foldr/internal-fmake';\n\n/**\n * Walks the given object or string and finds the property\n * defined by `path`, which is a \"path string\" in the format\n * `foo.bar.baz`, `foo[1].bar`, `foo[bar][baz]`.\n *\n * @name get\n * @param {Object|Array|String} object The object to \"get\" from.\n * @param {string} path The path of the property to get.\n * @param {any=} fallback The fallback value if `undefined`\n * is returned from the lookup.\n * @returns {any} The value of off `object` at the given path.\n *\n * @category utility\n * @publishdoc\n * @since v0.0.0\n * @export\n * @export\n * @example\n *\n * const thing = { foo: [{ bar: 1 }, { bar: 2 }, { bar: 3 }]};\n * get(thing, 'foo');             // => [{ bar: 1 }, { bar: 2 }, { bar: 3 }]\n * get(thing, 'foo[0]');          // => { bar: 1 }\n * get(thing, 'foo[0].bar');      // => 1\n * get(thing, 'foo[0].bar.baz');  // => undefined\n *\n * // Using a fallback value if the item at path doesn't exist or is undefined.\n * get(thing, 'foo.xxx', 'fallback'); // => 'fallback'\n */\nexport default function get(object, path, fallback) {\n  const props = toPath(path);\n  const size = props.length;\n\n  if (!size || !object) return fallback;\n\n  let current = object;\n  let i = 0;\n\n  if (size === 1) {\n    current = object[props[0]];\n  } else {\n    while (i < size && current != null) {\n      current = current[props[i++]];\n    }\n  }\n\n  return current === undefined ? fallback : current;\n}\n\n/**\n * Functional, autocurried version of [get](#get).\n *\n * Walks the given object or string and finds the property\n * defined by `path`, which is a \"path string\" in the format\n * `foo.bar.baz`, `foo[1].bar`, `foo[bar][baz]`.\n *\n * @name get.f\n * @param {Object|Array|String} object The object to walk.\n * @param {string} path The path of the property to get.\n * @returns {any} The value of off `object` at the given path.\n *\n * @arity 2\n * @autocurried\n * @category functional\n * @publishdoc\n * @since v0.0.0\n * @export\n * @export\n * @example\n *\n * const thing = {\n *   foo: [\n *     { bar: 1 },\n *     { bar: 2 },\n *     { bar: 3 }\n *   ],\n * };\n *\n * get.f('foo', thing);             // => [{ bar: 1 }, { bar: 2 }, { bar: 3 }]\n * get.f('foo[0]')(thing);          // => { bar: 1 }\n * get.f('foo[0].bar', thing);      // => 1\n * get.f('foo[0].bar.baz')(thing);  // => undefined\n */\nexport const f = FunctionalFactory(get, {\n  arity: 2,\n  signature: [1, 0],\n});\n"]}