{"version":3,"sources":["index.js"],"names":["invoke","object","path","args","props","size","length","i","fn","context","apply","f","arity","signature"],"mappings":"0TAsCe,QAASA,CAAAA,MAAT,CAAgBC,CAAhB,CAAwBC,CAAxB,CAA8BC,CAA9B,CAAoC,CACjD,GAAI,CAACF,CAAL,CAAa,OADoC,GAI3CG,CAAAA,CAAK,CAAG,oBAAOF,CAAP,CAJmC,CAK3CG,CAAI,CAAGD,CAAK,CAACE,MAL8B,CAOjD,GAAI,CAACD,CAAL,CAAW,OAPsC,GAS7CE,CAAAA,CAAC,CAAG,CATyC,CAU7CC,CAAE,CAAGP,CAVwC,CAW7CQ,CAAO,CAAGR,CAXmC,CAcjD,MAAOM,CAAC,CAAGF,CAAJ,EAAkB,IAAN,EAAAG,CAAnB,CAA+B,CAC7BC,CAAO,CAAGD,CAAV,CACAA,CAAE,CAAGA,CAAE,CAACJ,CAAK,CAACG,CAAC,EAAF,CAAN,CACR,CAED,GAAkB,UAAd,QAAOC,CAAAA,CAAX,CAA8B,OAC9B,MAAOA,CAAAA,CAAE,CAACE,KAAH,CAASD,CAAT,CAAkBN,CAAI,EAAoB,QAAhB,QAAOA,CAAAA,CAAf,CAAmCA,CAAnC,OAAlB,CACR,CAkCM,GAAMQ,CAAAA,CAAC,CAAG,2BAAkBX,MAAlB,CAA0B,CACzCY,KAAK,CAAE,CADkC,CAEzCC,SAAS,CAAE,CAAC,CAAD,CAAI,CAAJ,CAAO,CAAP,CAF8B,CAA1B,CAAV,C","sourceRoot":"packages/categories/functional/invoke-fx","sourcesContent":["/**\n * Exports the `invoke` function.\n * @since 11/14/18\n * @file\n */\n\nimport toPath from '@foldr/to-path';\nimport FunctionalFactory from '@foldr/internal-fmake';\n\n/**\n * Invokes the function at `path` of `object`.\n * `invoke` will use the `this` binding of the object the function belongs to.\n *\n * @name invoke\n * @param {Object} object The object to walk and get the function to invoke from.\n * @param {Array|string} path The path to query `object` using.\n * @param {Array=} args A list of arguments to call the function with.\n * @returns {any} The return value from the invoked function. If the property\n * at path isn't a function `undefined` is returned.\n *\n * @category function\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * const object = {\n *   foo: {\n *     bar() {\n *       return 'invoked!';\n *     },\n *     baz: [1, 2, 3, 4],\n *   },\n * };\n *\n * invoke(object, 'foo.bar');               // => 'invoked!'\n * invoke(object, 'foo.baz.slice', [0, 3]); // => [1, 2, 3]\n */\nexport default function invoke(object, path, args) {\n  if (!object) return undefined;\n\n  // Convert the path to an array of path tokens.\n  const props = toPath(path);\n  const size = props.length;\n\n  if (!size) return undefined;\n\n  let i = 0;\n  let fn = object;\n  let context = object;\n\n  // Perform function lookup by walking the object\n  while (i < size && fn != null) {\n    context = fn;\n    fn = fn[props[i++]];\n  }\n\n  if (typeof fn !== 'function') return undefined;\n  return fn.apply(context, args && typeof args === 'object' ? args : undefined);\n}\n\n/**\n * Functional, autocurried version of [invoke](#invoke).\n *\n * Invokes the function at `path` of `object`.\n *\n * @name invoke.f\n * @param {Array|string} path The path to query `object` using.\n * @param {Array=} args A list of arguments to call the function with.\n * @param {Object} object The object to walk and get the function to invoke from.\n * @returns {any} The return value from the invoked function. If the property\n * at path isn't a function `undefined` is returned.\n *\n * @arity 3\n * @autocurried\n * @category function\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * const object = {\n *   foo: {\n *     bar() {\n *       return 'invoked!';\n *     },\n *     baz: [1, 2, 3, 4],\n *   },\n * };\n *\n * invoke('foo.bar', [])(object);           // => 'invoked!'\n * invoke('foo.baz.slice', [0, 3])(object); // => [1, 2, 3]\n */\nexport const f = FunctionalFactory(invoke, {\n  arity: 3,\n  signature: [2, 0, 1],\n});\n"]}