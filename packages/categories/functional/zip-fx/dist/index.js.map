{"version":3,"sources":["index.js"],"names":["zip","args","arguments","size","length","results","filtered","i","n","z","current","f","arity","signature"],"mappings":"kUA2Be,QAASA,CAAAA,GAAT,EAAe,IACtBC,CAAAA,CAAI,CAAGC,SADe,CAEtBC,CAAI,CAAGF,CAAI,CAACG,MAFU,CAI5B,GAAI,CAACD,CAAL,CAAW,MAAO,EAAP,CAJiB,GAMtBE,CAAAA,CAAO,CAAG,EANY,CAOtBC,CAAQ,CAAG,EAPW,CASxBC,CAAC,CAAG,CAToB,CAUxBC,CAAC,CAAG,CAVoB,CAWxBC,CAAC,CAAG,CAXoB,CAYxBC,CAZwB,CAc5B,MAAOH,CAAC,CAAGJ,CAAX,CAAiB,CACfO,CAAO,CAAGT,CAAI,CAACM,CAAC,EAAF,CAAd,CAEA,GAAI,yBAAYG,CAAZ,CAAJ,CAA0B,CACxBJ,CAAQ,CAACG,CAAC,EAAF,CAAR,CAAgBC,CAAhB,CACAA,CAAO,CAAGA,CAAO,CAACN,MAAlB,CACA,GAAII,CAAC,CAAGE,CAAR,CAAiBF,CAAC,CAAGE,CACtB,CACF,CAED,MAAc,CAAP,IAAEF,CAAT,CAAiB,CACfD,CAAC,CAAGE,CAAJ,CACAJ,CAAO,CAACG,CAAD,CAAP,CAAa,EAAb,CAEA,MAAc,CAAP,IAAED,CAAT,CAAiB,CACfF,CAAO,CAACG,CAAD,CAAP,CAAWD,CAAX,EAAgBD,CAAQ,CAACC,CAAD,CAAR,CAAYC,CAAZ,CACjB,CACF,CAED,MAAOH,CAAAA,CACR,CA8BM,GAAMM,CAAAA,CAAC,CAAG,2BAAkBX,GAAlB,CAAuB,CACtCY,KAAK,CAAE,CAD+B,CAEtCC,SAAS,CAAE,CAAC,CAAD,CAAI,CAAJ,CAF2B,CAAvB,CAAV,C","sourceRoot":"packages/categories/functional/zip-fx","sourcesContent":["import isArrayLike from '@foldr/is-array-like';\nimport FunctionalFactory from '@foldr/internal-fmake';\n\n/**\n * Creates an array of values grouped by index.\n *\n * Returns an array of grouped arrays from the elements of the arrays provided. That is,\n * all elements of the first array in the returned array are the 0th index, the second array\n * in the return array is all the elements at index 1, and so on.\n *\n * This method operates on \"array-like\" objects so Arguments and strings will work as expected.\n * Non-array-like values will be ignored from the input arguments.\n *\n * @name zip\n * @param {...Array} The arrays to zip.\n * @returns {Array<Array>} The (grouped) arrays.\n *\n * @category array\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * zip([1, 2, 3], ['a', 'b', 'c']); // => [[1, 'a'], [2, 'b'], [3, 'c']]\n * zip(['x', 1], ['y', 2]);         // => [['x', 'y'], [1, 2]]\n * zip('foo', 'bar');               // => [['f', 'b'], ['o', 'a'], ['a', 'r']]\n */\nexport default function zip() {\n  const args = arguments;\n  const size = args.length;\n\n  if (!size) return [];\n\n  const results = [];\n  const filtered = [];\n\n  let i = 0;\n  let n = 0;\n  let z = 0;\n  let current;\n\n  while (i < size) {\n    current = args[i++];\n\n    if (isArrayLike(current)) {\n      filtered[z++] = current;\n      current = current.length;\n      if (n < current) n = current;\n    }\n  }\n\n  while (--n >= 0) {\n    i = z;\n    results[n] = [];\n\n    while (--i >= 0) {\n      results[n][i] = filtered[i][n];\n    }\n  }\n\n  return results;\n}\n\n/**\n * Functional, autocurried version of [zip](#zip).\n * Creates an array of values grouped by index.\n *\n * Returns an array of grouped arrays from the elements of the arrays provided. That is,\n * all elements of the first array in the returned array are the 0th index, the second array\n * in the return array is all the elements at index 1, and so on.\n *\n * This method operates on \"array-like\" objects so Arguments and strings will work as expected.\n * Non-array-like values will be ignored from the input arguments.\n *\n * @name zip.f\n * @param {Array} y The second array to zip using.\n * @param {Array} x The first array to zip using.\n * @returns {Array<Array>} The (grouped) arrays.\n *\n * @arity 2\n * @autocurried\n * @category functional\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * zip.f(['a', 'b', 'c'], [1, 2, 3]); // => [[1, 'a'], [2, 'b'], [3, 'c']]\n * zip.f(['y', 2], ['x', 1]);         // => [['x', 'y'], [1, 2]]\n * zip.f('bar')('foo');               // => [['f', 'b'], ['o', 'a'], ['a', 'r']]\n */\nexport const f = FunctionalFactory(zip, {\n  arity: 2,\n  signature: [1, 0],\n});\n"]}