{"version":3,"sources":["index.js"],"names":["INF","clamp","x","lower","upper"],"mappings":"0FAAA,kE,wEAEA,GAAMA,CAAAA,GAAG,IAAT,CAmCe,QAASC,CAAAA,KAAT,CAAeC,CAAf,CAAkBC,CAAlB,CAAyBC,CAAzB,CAAgC,CAE7C,GAAIA,CAAK,SAAT,CAAyB,CACvBA,CAAK,CAAGD,CAAR,CACAA,CAAK,CAAG,CAACH,GACV,CAEDE,CAAC,CAAG,sBAASA,CAAT,CAAJ,CAGA,GAAIA,CAAC,GAAKA,CAAV,CAAa,MAAOA,CAAAA,CAAP,CAEbC,CAAK,CAAG,sBAASA,CAAT,CAAR,CACAC,CAAK,CAAG,sBAASA,CAAT,CAAR,CAGA,GAAIA,CAAK,GAAKA,CAAd,CAAqBA,CAAK,CAAGJ,GAAR,CACrB,GAAIG,CAAK,GAAKA,CAAd,CAAqBA,CAAK,CAAG,CAACH,GAAT,CAGrB,GAAIG,CAAK,CAAGC,CAAZ,CAAmBA,CAAK,CAAGD,CAAR,CACnB,MAAOD,CAAAA,CAAC,CAAGC,CAAJ,CAAYA,CAAZ,CAAoBD,CAAC,CAAGE,CAAJ,CAAYA,CAAZ,CAAoBF,CAChD","sourceRoot":"packages/categories/number/clamp","sourcesContent":["import toNumber from '@foldr/to-number';\n\nconst INF = Infinity;\n\n/* eslint-disable no-nested-ternary, no-param-reassign, no-self-compare */\n\n/**\n * Clamps a number in the range `lower` and `upper`.\n * If `lower` in greater than `upper`, `lower` takes precedence.\n *\n * If called with only two arguments, the signature becomes: `clamp(x, upper)`.\n *\n * This function will coerce `x`, `lower`, and `upper` to numbers,\n * so string values like `'1'` and `'0b101'` can be used.\n *\n * If `x` is `NaN` it cannot be clamped, so `NaN` is returned.\n * If `lower` or `upper` is NaN, they are converted to `-Infinity`\n * and `Infinity`, respectively.\n *\n * @name clamp\n * @param {number} x The value to clamp.\n * @param {number=} lower The minimum value `x` can be.\n * @param {number} upper The maximum value `x` can be.\n * @returns {number} The clamped value.\n *\n * @category number\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * import { clamp } from '@foldr/all';\n *\n * clamp(5, 0, 10);   // => 5\n * clamp(-10, 0, 10); // => 0\n * clamp(20, 0, 10);  // => 10\n */\nexport default function clamp(x, lower, upper) {\n  // Note, if called with 2 arguments the signature will be clamp(x, upper).\n  if (upper === undefined) {\n    upper = lower;\n    lower = -INF;\n  }\n\n  x = toNumber(x);\n\n  // `x` is NaN, don't even attempt to clamp.\n  if (x !== x) return x;\n\n  lower = toNumber(lower);\n  upper = toNumber(upper);\n\n  // Either `upper` or `lower` is NaN\n  if (upper !== upper) upper = INF;\n  if (lower !== lower) lower = -INF;\n\n  // Note, if lower > upper, lower has precedence.\n  if (lower > upper) upper = lower;\n  return x < lower ? lower : x > upper ? upper : x;\n}\n"]}