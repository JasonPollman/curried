{"version":3,"sources":["index.js"],"names":["INTERPOLATOR_RE_CACHE","identity","x","getInterpolationRegExp","start","end","key","RegExp","replacer","tokens","escape","strict","onReplacement","$0","$1","$2","$3","slice","interpolate","options","string","settings","delimiters","delims","interpolator","toString","replace"],"mappings":"sYAIO,GAAMA,CAAAA,qBAAqB,CAAG,EAA9B,C,oDAOP,GAAMC,CAAAA,QAAQ,CAAG,SAAAC,CAAC,QAAIA,CAAAA,CAAJ,CAAlB,CAYA,QAASC,CAAAA,sBAAT,CAAgCC,CAAhC,CAAuCC,CAAvC,CAA4C,CAC1C,GAAMC,CAAAA,CAAG,CAAGF,CAAK,CAAGC,CAApB,CAEA,GAAI,CAACL,qBAAqB,CAACM,CAAD,CAA1B,CAAiC,CAC/BN,qBAAqB,CAACM,CAAD,CAArB,CAA6B,GAAIC,CAAAA,MAAJ,iBAAoBH,CAApB,gCAAgDC,CAAhD,MAAwD,IAAxD,CAC9B,CAED,MAAOL,CAAAA,qBAAqB,CAACM,CAAD,CAC7B,CAkBD,QAASE,CAAAA,QAAT,GAA+EC,CAA/E,CAAuF,SAAnEC,MAAmE,CAAnEA,CAAmE,YAA1D,IAA0D,OAApDC,MAAoD,CAApDA,CAAoD,qBAApCC,aAAoC,CAApCA,CAAoC,YAApBX,QAAoB,GACrF,MAAO,UAACY,CAAD,CAAKC,CAAL,CAASC,CAAT,CAAaC,CAAb,CAAoB,CACzB,GAAIH,CAAE,CAAC,CAAD,CAAF,GAAUH,CAAd,CAAsB,MAAOG,CAAAA,CAAE,CAACI,KAAH,CAAS,CAAT,CAAP,CACtB,gBAAUH,CAAV,SAAeF,CAAa,CAAC,iBAAIH,CAAJ,CAAYO,CAAZ,CAAgBL,CAAM,CAAGI,CAAH,CAAQ,EAA9B,CAAD,CAAoCC,CAApC,CAAwCD,CAAxC,CAA5B,CACD,CACF,CA2CD,QAASG,CAAAA,WAAT,CAAqBC,CAArB,CAA8BC,CAA9B,CAAsCX,CAAtC,CAA8C,IACtCY,CAAAA,CAAQ,CAAGF,CAAO,EAAI,EADgB,CAEtCG,CAAU,CAAGD,CAAQ,CAACE,MAAT,EAAmB,EAFM,CAItCC,CAAY,CAAGrB,sBAAsB,CACzC,0BAAamB,CAAU,CAAC,CAAD,CAAV,EAAiB,GAA9B,EAAmCG,QAAnC,EADyC,CAEzC,0BAAaH,CAAU,CAAC,CAAD,CAAV,EAAiB,GAA9B,EAAmCG,QAAnC,EAFyC,CAJC,CAS5C,MAAiB,KAAV,EAAAL,CAAM,CAAW,EAAX,CAAgBA,CAAM,CAACK,QAAP,GAAkBC,OAAlB,CAA0BF,CAA1B,CAAwChB,QAAQ,CAACa,CAAD,CAAWZ,CAAX,CAAhD,CAC9B,C,aAEc,2BAAMS,WAAN,C","sourceRoot":"packages/categories/string/interpolate","sourcesContent":["import get from '@foldr/get';\nimport curry from '@foldr/internal-curry';\nimport escapeRegExp from '@foldr/escape-regexp';\n\nexport const INTERPOLATOR_RE_CACHE = {};\n\n/**\n * Identity function.\n * @param {any} x The passthrough value.\n * @returns {any} The value of `x`.\n */\nconst identity = x => x;\n\n/**\n * Creating interpolation regular expressions is both few and far\n * between and expensive, so we'll be caching them.\n * Gets the cached regular expression for the current delimiter.\n * If the current start/end delimiter combination isn't cached or\n * hasn't been used yet, the regular expression is created.\n * @param {string} start The start delimiter.\n * @param {string} end The end delimiter.\n * @returns {RegExp} The cached regular expression.\n */\nfunction getInterpolationRegExp(start, end) {\n  const key = start + end;\n\n  if (!INTERPOLATOR_RE_CACHE[key]) {\n    INTERPOLATOR_RE_CACHE[key] = new RegExp(`(^|.)(${start}\\\\s*([\\\\s\\\\S]*?)\\\\s*${end})`, 'gm');\n  }\n\n  return INTERPOLATOR_RE_CACHE[key];\n}\n\n/**\n * Creates a replacer for an interpolator.\n * @param {Object} options Interpolation replacement options.\n * @param {string=} [options.escape='\\'] A string value that serves as a escape character\n * that indicates that the current match should be skipped. For example, if\n * '{', and '}' are the delimiters and `\\` is the escape character, then\n * `\\{foo}` wouldn't be interpolated, but `{foo}` would.\n * @param {string=} [options.strict=false] If true, if the matched value interpolated\n * isn't found in `tokens`, the original string is left untouched, otherwise it's\n * replaced with an empty string.\n * @param {function=} [options.onReplacement=identity] A function that's called each time\n * a replacement is made with the replacement value, the token path, and the\n * entire string being replaced.\n * @param {Object=} tokens The tokens that are available for interolation replacement.\n * @returns {function} A function that's passed to String#replace.\n */\nfunction replacer({ escape = '\\\\', strict = false, onReplacement = identity }, tokens) {\n  return ($0, $1, $2, $3) => {\n    if ($0[0] === escape) return $0.slice(1);\n    return `${$1}${onReplacement(get(tokens, $3, strict ? $2 : ''), $3, $2)}`;\n  };\n}\n\n/**\n * Interpolates `string` using `options`, replacing all values with properties from `tokens`.\n *\n * @name interpolate\n * @param {Object} options Interpolation options.\n * @param {Array<string>} options.delims A tuple in which the first element is the start\n * delimiter and the second is the end delimiter. For example ['{', '}'] would replace\n * `{xxx}` in `hello {xxx}!` with `tokens.xxx`.\n * @param {string=} [options.escape='\\'] A string value that serves as a escape character\n * that indicates that the current match should be skipped. For example, if\n * '{', and '}' are the delimiters and `\\` is the escape character, then\n * `\\{foo}` wouldn't be interpolated, but `{foo}` would.\n * @param {string=} [options.strict=false] If true, if the matched value interpolated\n * isn't found in `tokens`, the original string is left untouched, otherwise it's\n * replaced with an empty string.\n * @param {function=} [options.onReplacement=identity] A function that's called each time\n * a replacement is made with the replacement value, the token path, and the\n * entire string being replaced.\n * @param {string} string The string to interpolate.\n * @param {Object} tokens The set of tokens that can be used as replacements in `string`.\n * @returns {string} The interpolated string.\n *\n * @arity 3\n * @category string\n * @publishdoc\n * @since v0.0.0\n * @autocurried\n * @export\n * @example\n *\n * import { interpolate } from '@foldr/all';\n *\n * const string = 'The {verb} brown {thing} jumped over the lazy brown {animal}';\n *\n * interpolate({ delims: ['{', '}'] }, string, {\n *   verb: 'quick',\n *   thing: 'fox',\n *   animal: 'dog',\n * });\n * // => 'The quick brown fox jumped over the lazy brown dog'\n */\nfunction interpolate(options, string, tokens) {\n  const settings = options || {};\n  const delimiters = settings.delims || [];\n\n  const interpolator = getInterpolationRegExp(\n    escapeRegExp(delimiters[0] || '{').toString(),\n    escapeRegExp(delimiters[1] || '}').toString(),\n  );\n\n  return string == null ? '' : string.toString().replace(interpolator, replacer(settings, tokens));\n}\n\nexport default curry(interpolate);\n"]}