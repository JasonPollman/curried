{"version":3,"sources":["index.js"],"names":["MAX_ITEMS","cache","memoize","Cache","resolver","args","size","clear","toStringPath","path","results","length","i","n","inString","stringQuoteCharacter","inBrackets","token","char","toStringPathMemoized","toPath","value"],"mappings":"oXAIMA,CAAAA,SAAS,CAAG,G,CACLC,KAAK,CAAG,GAAIC,kBAAQC,K,qBAOjC,QAASC,CAAAA,QAAT,CAAkBC,CAAlB,CAAwB,CACtB,GAAIJ,KAAK,CAACK,IAAN,CAAaN,SAAjB,CAA4BC,KAAK,CAACM,KAAN,GAC5B,MAAOF,CAAAA,CAAI,CAAC,CAAD,CACZ,CAOD,QAASG,CAAAA,YAAT,CAAsBC,CAAtB,CAA4B,IACpBC,CAAAA,CAAO,CAAG,EADU,CAEpBJ,CAAI,CAAGG,CAAI,CAACE,MAFQ,CAI1B,GAAI,CAACF,CAAD,EAAS,CAACH,CAAd,CAAoB,MAAOI,CAAAA,CAAP,CAJM,GAMtBE,CAAAA,CAAC,CAAG,CANkB,CAOtBC,CAAC,CAAG,CAPkB,CAWtBC,CAAQ,GAXc,CActBC,CAdsB,CAiBtBC,CAAU,GAjBY,CAqBtBC,CAAK,CAAG,EArBc,CAuB1B,MAAOL,CAAC,CAAGN,CAAX,CAAiB,CACf,GAAMY,CAAAA,CAAI,CAAGT,CAAI,CAACG,CAAC,EAAF,CAAjB,CAEA,OAAQM,CAAR,EACE,IAAK,GAAL,CAGE,GAAI,CAACJ,CAAD,EAAa,CAACE,CAAlB,CAA8B,CAC5B,GAAIC,CAAJ,CAAW,CACTP,CAAO,CAACG,CAAC,EAAF,CAAP,CAAeI,CAAf,CACAA,CAAK,CAAG,EACT,CACF,CALD,IAKO,CACLA,CAAK,EAAIC,CACV,CAED,MAEF,IAAK,GAAL,CAGE,GAAI,CAACJ,CAAD,EAAa,CAACE,CAAlB,CAA8B,CAC5BA,CAAU,GAAV,CAEA,GAAIC,CAAJ,CAAW,CACTP,CAAO,CAACG,CAAC,EAAF,CAAP,CAAeI,CAAf,CACAA,CAAK,CAAG,EACT,CACF,CAPD,IAOO,CACLA,CAAK,EAAIC,CACV,CAED,MAEF,IAAK,GAAL,CAGE,GAAI,CAACJ,CAAD,EAAaE,CAAjB,CAA6B,CAC3BA,CAAU,GAAV,CAEA,GAAIC,CAAJ,CAAW,CACTP,CAAO,CAACG,CAAC,EAAF,CAAP,CAAeI,CAAf,CACAA,CAAK,CAAG,EACT,CACF,CAPD,IAOO,CACLA,CAAK,EAAIC,CACV,CAED,MAEF,IAAK,IAAL,CACA,IAAK,GAAL,CACE,GAAI,CAACJ,CAAL,CAAe,CAGbA,CAAQ,GAAR,CACAC,CAAoB,CAAGG,CAAvB,CACA,GAAI,CAACF,CAAL,CAAiBC,CAAK,EAAIC,CAC3B,CAND,IAMO,IAAIH,CAAoB,GAAKG,CAA7B,CAAmC,CAGxCJ,CAAQ,GAAR,CACA,GAAI,CAACE,CAAL,CAAiBC,CAAK,EAAIC,CAC3B,CALM,IAKA,CAGLD,CAAK,EAAIC,CACV,CAED,MAEF,QACED,CAAK,EAAIC,CAAT,CArEJ,CAuED,CAED,GAAID,CAAJ,CAAWP,CAAO,CAACG,CAAD,CAAP,CAAaI,CAAb,CACX,MAAOP,CAAAA,CACR,CAED,GAAMS,CAAAA,oBAAoB,CAAG,qBAAQX,YAAR,CAAsBJ,QAAtB,CAAgCH,KAAhC,CAA7B,CAwBe,QAASmB,CAAAA,MAAT,CAAgBC,CAAhB,CAAuB,CACpC,MAAO,qBAAQA,CAAR,EAAiBA,CAAjB,CAAyBF,oBAAoB,CAAC,sBAASE,CAAT,CAAD,CACrD","sourceRoot":"packages/categories/utility/to-path","sourcesContent":["import memoize from '@foldr/memoize';\nimport isArray from '@foldr/is-array';\nimport toString from '@foldr/to-string';\n\nconst MAX_ITEMS = 100;\nexport const cache = new memoize.Cache();\n\n/**\n * The cache resolver for the memoized `toPath` method.\n * @param {Arguments} args The arguments from the call to the memoized method.\n * @returns {any} The first argument.\n */\nfunction resolver(args) {\n  if (cache.size > MAX_ITEMS) cache.clear();\n  return args[0];\n}\n\n/**\n * Converts a string to an array of object path tokens.\n * @param {string} path The value to convert to a set of path tokens.\n * @returns {Array} An array of paths.\n */\nfunction toStringPath(path) {\n  const results = [];\n  const size = path.length;\n\n  if (!path || !size) return results;\n\n  let i = 0;\n  let n = 0;\n\n  // True if inside of a string. Note, that mismatched\n  // quote types are handled as expected.\n  let inString = false;\n\n  // The type of string we're inside of, either `'` or `\"`.\n  let stringQuoteCharacter;\n\n  // True if inside a brackets sequence ([ ... ])\n  let inBrackets = false;\n\n  // Keeps track of the current path \"token\". This is appended to\n  // with each character as the path string is iterated over.\n  let token = '';\n\n  while (i < size) {\n    const char = path[i++];\n\n    switch (char) {\n      case '.':\n        // If we're not in a string or inside of a bracket set, then\n        // this dot represents a \"jump\" to the next property in the path.\n        if (!inString && !inBrackets) {\n          if (token) {\n            results[n++] = token;\n            token = '';\n          }\n        } else {\n          token += char;\n        }\n\n        break;\n\n      case '[':\n        // If we're not in a string or currently inside of a bracket set, then\n        // this open bracket represents a \"jump\" to the next property in the path.\n        if (!inString && !inBrackets) {\n          inBrackets = true;\n\n          if (token) {\n            results[n++] = token;\n            token = '';\n          }\n        } else {\n          token += char;\n        }\n\n        break;\n\n      case ']':\n        // If we're not in a string and we are inside of a bracket set, then\n        // this close bracket represents a \"jump\" to the next property in the path.\n        if (!inString && inBrackets) {\n          inBrackets = false;\n\n          if (token) {\n            results[n++] = token;\n            token = '';\n          }\n        } else {\n          token += char;\n        }\n\n        break;\n\n      case '\"':\n      case \"'\":\n        if (!inString) {\n          // Found an opening quote.\n          // If we're not inside of brackets, consider the quote as part of the property name.\n          inString = true;\n          stringQuoteCharacter = char;\n          if (!inBrackets) token += char;\n        } else if (stringQuoteCharacter === char) {\n          // Found a closing quote.\n          // If we're not inside of brackets, consider the quote as part of the property name.\n          inString = false;\n          if (!inBrackets) token += char;\n        } else {\n          // Not a closing or opening quote, this is for cases like \"'\" and '\"'\n          // where we found quotes when already inside of a string.\n          token += char;\n        }\n\n        break;\n\n      default:\n        token += char;\n    }\n  }\n\n  if (token) results[n] = token;\n  return results;\n}\n\nconst toStringPathMemoized = memoize(toStringPath, resolver, cache);\n\n/**\n * Converts a string path (i.e. foo.bar.baz) to any array of \"path tokens\".\n * This works using both the dot and bracket notiation and supports strings.\n *\n * @name toPath\n * @param {string} value The value to convert to a path.\n * @returns {Array<string>} An array of paths.\n *\n * @arity 1\n * @category utility\n * @publishdoc\n * @since v0.0.0\n * @export\n * @example\n *\n * import { toPath } from '@foldr/all';\n *\n * toPath('foo');                  // => ['foo']\n * toPath('foo.bar.baz');          // => ['foo', 'bar', 'baz']\n * toPath('foo[bar].baz');         // => ['foo', 'bar', 'baz']\n * toPath('foo[0][1][\"bar\"].baz'); // => ['foo', '0', '1', 'bar', 'baz']\n */\nexport default function toPath(value) {\n  return isArray(value) ? value : toStringPathMemoized(toString(value));\n}\n"]}