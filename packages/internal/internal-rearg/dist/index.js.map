{"version":3,"sources":["index.js"],"names":["ARITY","IS_REARGED","SOURCE","toStringForRearged","concat","toString","reargWrap","fn","reargs","size","length","input","arguments","output","max","i","n","apply","rearg","signature","rearged"],"mappings":"iJAQA,8E,wEAMO,GAAMA,CAAAA,KAAK,CAAG,4BAAc,cAAd,CAAd,C,oBAMA,GAAMC,CAAAA,UAAU,CAAG,4BAAc,eAAd,CAAnB,C,8BAMA,GAAMC,CAAAA,MAAM,CAAG,4BAAc,WAAd,CAAf,C,sBASP,QAASC,CAAAA,kBAAT,EAA8B,CAC5B,MAAO,0BAA0BC,MAA1B,CAAiC,KAAKF,MAAL,EAAaG,QAAb,EAAjC,CACR,CAQD,QAASC,CAAAA,SAAT,CAAmBC,CAAnB,CAAuBC,CAAvB,CAA+B,CAC7B,GAAMC,CAAAA,CAAI,CAAGD,CAAM,CAACE,MAApB,CAEA,MAAO,WAAmB,IAClBC,CAAAA,CAAK,CAAGC,SADU,CAElBC,CAAM,CAAG,EAFS,CAIlBC,CAAG,CAAGH,CAAK,CAACD,MAAN,CAAeD,CAAf,CAAsBE,CAAK,CAACD,MAA5B,CAAqCD,CAJzB,CAMpBM,CAAC,CAAG,CANgB,CAOpBC,CAAC,CAAG,CAPgB,CAUxB,MAAOD,CAAC,CAAGD,CAAX,EAAgBD,CAAM,CAACG,CAAC,EAAF,CAAN,CAAcL,CAAK,CAACH,CAAM,CAACO,CAAC,EAAF,CAAP,CAAnC,CAEAA,CAAC,CAAGJ,CAAK,CAACD,MAAV,CAGA,MAAOM,CAAC,CAAGD,CAAX,EAAcF,CAAM,CAACG,CAAD,CAAN,CAAYL,CAAK,CAACK,CAAC,EAAF,CAA/B,CACA,MAAOT,CAAAA,CAAE,CAACU,KAAH,CAAS,IAAT,CAAeJ,CAAf,CACR,CACF,CAWc,QAASK,CAAAA,KAAT,CAAeX,CAAf,CAAmBY,CAAnB,CAA8B,CAC3C,GAAI,CAACA,CAAD,EAAc,CAACA,CAAS,CAACT,MAA7B,CAAqC,MAAOH,CAAAA,CAAP,CAErC,GAAMa,CAAAA,CAAO,CAAGd,SAAS,CAACC,CAAD,CAAKY,CAAL,CAAzB,CAEAC,CAAO,CAACpB,KAAD,CAAP,CAA8B,CAAb,EAAAO,CAAE,CAACP,KAAD,CAAF,CAAiBO,CAAE,CAACP,KAAD,CAAnB,CAA6BO,CAAE,CAACG,MAAjD,CACAU,CAAO,CAAClB,MAAD,CAAP,CAAkBK,CAAlB,CACAa,CAAO,CAACnB,UAAD,CAAP,IACAmB,CAAO,CAACf,QAAR,CAAmBF,kBAAnB,CAEA,MAAOiB,CAAAA,CACR,CAEDF,KAAK,CAACjB,UAAN,CAAmBA,UAAnB,CACAiB,KAAK,CAAChB,MAAN,CAAeA,MAAf","sourceRoot":"packages/internal/internal-rearg","sourcesContent":["/**\n * Exports the `rearg` function.\n * This version is for internal use only and doesn't\n * validate/sanitize any input arguments.\n * @since 11/10/18\n * @file\n */\n\nimport SafeSymbolFor from '@foldr/internal-symbol';\n\n/**\n * Used to track the arity of rearged functions.\n * @type {SafeSymbol}\n */\nexport const ARITY = SafeSymbolFor('source-arity');\n\n/**\n * Used to determine if a function is rearged.\n * @type {SafeSymbol}\n */\nexport const IS_REARGED = SafeSymbolFor('is-rearged-fn');\n\n/**\n * Used to stash the source function on the rearged function.\n * @type {SafeSymbol}\n */\nexport const SOURCE = SafeSymbolFor('source-fn');\n\n/**\n * The `toString` implementation for rearged functions.\n * This will print the original function's source string\n * prepended with a friendly message that the function is rearged.\n * @returns {string} The source function's code with a comment\n * informing the user that the function is rearged.\n */\nfunction toStringForRearged() {\n  return '/* Rearg Wrapped */\\r\\n'.concat(this[SOURCE].toString());\n}\n\n/**\n * Reargs `fn` using `signature`.\n * @param {function} fn The function to rearg.\n * @param {Array} reargs The reargument signature set.\n * @returns {function} The rearged function.\n */\nfunction reargWrap(fn, reargs) {\n  const size = reargs.length;\n\n  return function rearged() {\n    const input = arguments;\n    const output = [];\n\n    const max = input.length < size ? input.length : size;\n\n    let i = 0;\n    let n = 0;\n\n    // Push all \"re-arguments\" into the new arguments set.\n    while (i < max) output[n++] = input[reargs[i++]];\n\n    i = input.length;\n\n    // Push any remaining arguments onto the end of the new arguments set.\n    while (n < i) output[n] = input[n++];\n    return fn.apply(this, output);\n  };\n}\n\n/**\n * Creates a function that \"rearranges\" the arguments signature of `fn`.\n * @param {function} fn The function to rearg.\n * @param {Array<number>} signature An array who's values indicate the actual arguments\n * to use for that index of the array. For example, `[1, 0, 2]` would convert the arguments\n * signature `fn(x, y, z)` to `fn(y, x, z)`.\n * @returns {function} The rearged function.\n * @export\n */\nexport default function rearg(fn, signature) {\n  if (!signature || !signature.length) return fn;\n\n  const rearged = reargWrap(fn, signature);\n\n  rearged[ARITY] = fn[ARITY] >= 0 ? fn[ARITY] : fn.length;\n  rearged[SOURCE] = fn;\n  rearged[IS_REARGED] = true;\n  rearged.toString = toStringForRearged;\n\n  return rearged;\n}\n\nrearg.IS_REARGED = IS_REARGED;\nrearg.SOURCE = SOURCE;\n"]}